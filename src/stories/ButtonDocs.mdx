import { Meta, Source, Canvas, Stories, Story } from "@storybook/blocks";
import { Button } from "./Button";
import * as ButtonStories from "./Button.stories";
import { Primary } from "./Button.stories";

<Meta of={ButtonStories} />

<Canvas source={{ code: 'whatever you want to display' }} />


<Source
  code={`const thisIsCustomSource = true;
if (isSyntaxHighlighted) {
  console.log('syntax highlighting is working');
}
<Button label="Click Me" onClick={logArray} />
`}
/>

<Canvas
  
  code={`const thisIsCustomSource = true;
if (isSyntaxHighlighted) {
  console.log('syntax highlighting is working');
}
<Button label="Click Me" onClick={logArray} />
`}
/>
<Canvas>
  {() => <Primary {...Primary.args} />}
</Canvas>
### Primary Button
<Canvas>

<Story name="Full Source Button">
    {() => {
      const arr = ['a', 'b', 'c'];
      const handleClick = () => console.log('Array:', arr);

      return (
        <div>
          <Button label="Click Me" onClick={handleClick} />
          <p>{`Array contents: ${arr.join(', ')}`}</p>
        </div>
      );
    }}
</Story>
</Canvas>

- **Why This Works**:
  - The markdown code block (` ```javascript `) provides a static display of the full code.
  - The `<Canvas>` renders the live component, even if Storybook cannot capture all inline logic automatically.

---

### **Option 4: Decorators to Capture Extra Logic**

If you want shared logic like `const` and `function` definitions across multiple stories, use a decorator.

### Primary Button

<Canvas sourceState='shown' code="sinbad">
  {() => <Primary {...Primary.args} />}
</Canvas>
#### Example `.storybook/preview.js`:
```javascript
export const decorators = [
  (Story) => {
    const arr = ['shared1', 'shared2', 'shared3'];
    const logArray = () => console.log('Shared Array:', arr);

    return (
      <div>
        <Story />
        <p>{`Shared Array Contents: ${arr.join(', ')}`}</p>
        <button onClick={logArray}>Log Shared Array</button>
      </div>
    );

},
];
